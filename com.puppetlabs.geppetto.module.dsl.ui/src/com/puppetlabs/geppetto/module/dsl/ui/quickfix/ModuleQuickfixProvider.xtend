/*
* generated by Xtext
*/
package com.puppetlabs.geppetto.module.dsl.ui.quickfix

import com.google.inject.Inject
import com.puppetlabs.geppetto.forge.model.ModuleName
import com.puppetlabs.geppetto.module.dsl.ModuleUtil
import com.puppetlabs.geppetto.module.dsl.metadata.JsonDependency
import com.puppetlabs.geppetto.module.dsl.metadata.JsonMetadata
import com.puppetlabs.geppetto.module.dsl.ui.preferences.ModulePreferencesHelper
import com.puppetlabs.geppetto.module.dsl.validation.ModuleDiagnostics
import org.eclipse.core.resources.IFile
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue

/**
 * Custom quickfixes.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#quickfixes
 */
class ModuleQuickfixProvider extends DefaultQuickfixProvider {
	@Inject
	extension ModuleUtil

	@Inject
	ModulePreferencesHelper preferenceHelper

	def private getResolvedMetadataVersion(EObject element) {
		(element.eContainer.eContainer as JsonDependency).referencedModule.version
	}

	def getModuleOwner() {
		var moduleOwner = preferenceHelper.forgeLogin
		if (moduleOwner === null)
			moduleOwner = ModuleName.safeOwner(System.getProperty("user.name"))
		moduleOwner
	}

	@Fix(ModuleDiagnostics::ISSUE__MISSING_REQUIRED_ATTRIBUTE)
	def addMissingAttribute(Issue issue, IssueResolutionAcceptor acceptor) {
		val key = issue.data.get(0)
		acceptor.accept(issue, 'Add entry for "' + key + '"',
			'Add missing entry for attribute "' + key + '"with template value', null) [ element, context |
			val doc = context.xtextDocument
			val bld = new StringBuilder
			bld.append('"')
			bld.append(key)
			bld.append('": "')
			context.xtextDocument
			switch key {
				case 'version':
					bld.append('0.1.0')
				case 'version_requirement':
					bld.append('>=0.0.0')
				case 'author':
					bld.append(moduleOwner)
				case 'name': {
					if (element instanceof JsonMetadata) {
						bld.append(moduleOwner)
						bld.append('-')
						bld.append(ModuleName.safeName(doc.getAdapter(IFile).parent.name, false))
					}
				}
			}
			bld.append('",\n  ')
			doc.replace(issue.offset, 0, bld.toString)
		]
	}

	@Fix(ModuleDiagnostics::ISSUE__MODULE_VERSION_RANGE_MISMATCH)
	def selectMatchingRange(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Use matching >=n.n.n range',
			"Change to a range that matches versions\ngreater or equal to the selected module", null) [ element, context |
			val bld = new StringBuilder
			bld.append('">=')
			element.resolvedMetadataVersion.toString(bld)
			bld.append('"')
			context.xtextDocument.replace(issue.offset, issue.length, bld.toString)
		]
		acceptor.accept(issue, 'Use matching n.x range',
			"Change to a range that matches versions\nwith the same major number as selected module", null) [ element, context |
			val bld = new StringBuilder
			bld.append('"')
			bld.append(element.resolvedMetadataVersion.major)
			bld.append(".x\"")
			context.xtextDocument.replace(issue.offset, issue.length, bld.toString)
		]
		acceptor.accept(issue, 'Use matching n.n.x range',
			"Change to a range that matches versions\nwith the same major and minor number as selected module", null) [ element, context |
			val v = element.resolvedMetadataVersion
			val bld = new StringBuilder
			bld.append('"')
			bld.append(v.major)
			bld.append('.')
			bld.append(v.minor)
			bld.append(".x\"")
			context.xtextDocument.replace(issue.offset, issue.length, bld.toString)
		]
		acceptor.accept(issue, 'Use exact range',
			"Change to a range exactly matches the version\nof the selected module", null) [ element, context |
			val bld = new StringBuilder
			bld.append('"')
			element.resolvedMetadataVersion.toString(bld)
			bld.append('"')
			context.xtextDocument.replace(issue.offset, issue.length, bld.toString)
		]
	}
}
